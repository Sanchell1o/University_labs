Лабораторная 3\.

В этой лабораторной работе вашей задачей является написать симулятор игры «Жизнь».


Игру «Жизнь» изобрел математик [Джон Хортон Конвей](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D0%B2%D0%B5%D0%B9,_%D0%94%D0%B6%D0%BE%D0%BD_%D0%A5%D0%BE%D1%80%D1%82%D0%BE%D0%BD) в 1970 году. Она пользовалась популярностью не только среди его коллег. Об увлекательности игры «Жизнь» свидетельствуют результаты множества интересных исследований и многочисленные компьютерные реализации. При этом она имеет непосредственное отношение к перспективной области математики \- теории [клеточных автоматов](https://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B5%D1%82%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82).

Правила игры «Жизнь» достаточно простые:

* «Жизнь» разыгрывается на бесконечном клеточном поле.  
* У каждой клетки 8 соседних клеток.  
* В каждой клетке может жить существо.  
* Существо с двумя или тремя соседями выживает в следующем поколении, иначе погибает от одиночества или перенаселённости.  
* В пустой клетке с тремя соседями в следующем поколении рождается существо \[1\].

Для реализации клеточного поля мы будем использовать набор модулей [pygame](http://pygame.org/hifi.html), предназначенный для создания компьютерных игр.

Для начала нам нужно создать игровое поле, на котором будет разворачиваться действие игры «Жизнь». Поэтому напишем класс GameOfLife, который принимает следующие параметры:

* width \- ширина окна (по умолчанию 640px);  
* height \- высота окна (по умолчанию 480px);  
* cell\_size \- высота и ширина клетки (по умолчанию 10px).


Далее представлен листинг, который позволяет создать игровое поле:

import pygame  
from pygame.locals import \*

class GameOfLife:  
    def \_\_init\_\_(self, width \= 640, height \= 480, cell\_size \= 10, speed \= 10\):  
        self.width \= width  
        self.height \= height  
        self.cell\_size \= cell\_size

        \# Устанавливаем размер окна  
        self.screen\_size \= width, height  
        \# Создание нового окна  
        self.screen \= pygame.display.set\_mode(self.screen\_size)

        \# Вычисляем количество ячеек по вертикали и горизонтали  
        self.cell\_width \= self.width // self.cell\_size  
        self.cell\_height \= self.height // self.cell\_size

        \# Скорость протекания игры  
        self.speed \= speed

   def draw\_grid(self):  
        \# [http://www.pygame.org/docs/ref/draw.html\#pygame.draw.line](http://www.pygame.org/docs/ref/draw.html#pygame.draw.line)  
        for x in range(0, self.width, self.cell\_size):  
            pygame.draw.line(self.screen, pygame.Color('black'),   
                (x, 0), (x, self.height))  
        for y in range(0, self.height, self.cell\_size):  
            pygame.draw.line(self.screen, pygame.Color('black'),   
                (0, y), (self.width, y))

   def run(self):  
        pygame.init()  
        clock \= pygame.time.Clock()  
        pygame.display.set\_caption('Game of Life')  
        self.screen.fill(pygame.Color('white'))  
        running \= True  
        while running:  
            for event in pygame.event.get():  
                if event.type \== QUIT:  
                    running \= False  
            self.draw\_grid()  
            pygame.display.flip()  
            clock.tick(self.speed)  
        pygame.quit()

if \_\_name\_\_ \== '\_\_main\_\_':  
    game \= GameOfLife(320, 240, 20)  
    game.run()

Подробное описание всех используемых функций из pygame читайте в официальной [документации](http://www.pygame.org/docs/ref/pygame.html).

Каждая клетка может находиться в двух состояниях: "*живая*" или "*мертвая*". Нам нужно создать список (матрицу) клеток размером cell\_height 

×

× cell\_width, которые в дальнейшем мы будем отображать на нашем поле, окрашивая их в зеленый и белый цвета, для "живых" и "мертвых" клеток соответственно.

def cell\_list(self, randomize=False):  
    """  
    Создание списка клеток.

    Клетка считается живой, если ее значение равно 1\.   
    В противном случае клетка считается мертвой, то   
    есть ее значение равно 0\.  
    Если параметр randomize \= True, то создается список, где  
    каждая клетка может быть равновероятно живой или мертвой.  
    """  
    pass

Пример использования:

\>\>\> from pprint import pprint as pp  
\>\>\> game \= GameOfLife(320, 240, 40)  
\>\>\> clist \= game.cell\_list(randomize=True)  
\>\>\> pp(clist)  
\[\[1, 1, 0, 0, 1, 1, 1, 1\],  
 \[0, 1, 1, 1, 1, 1, 1, 0\],  
 \[1, 0, 1, 1, 0, 0, 0, 0\],  
 \[1, 0, 0, 0, 0, 0, 0, 1\],  
 \[1, 0, 1, 1, 1, 1, 0, 0\],  
 \[1, 1, 1, 1, 0, 1, 1, 1\]\]

Теперь нам нужно окрашивать клетки в зеленый или белый цвета в зависимости от того живая клетка или мертвая. Каждая клетка на поле представлена прямоугольником размера cell\_size 

×

× cell\_size, который можно закрасить с помощью функции pygame.draw.rect. Эта функция принимает следующие параметры:

* Surface \- где нужно отрисовать прямоугольник (в нашем случае это screen);  
* color \- цвет, которым следует закрасить прямоугольник (pygame.Color('white') или pygame.Color('green'));  
* Rect \- координаты прямоугольника в формате (x, y, длина стороны a, длина стороны b).

def draw\_cell\_list(self, rects):  
    """  
    Отображение списка клеток 'rects' с закрашиванием их в   
    соответствующе цвета  
    """  
    pass

Добавьте вызовы метода draw\_cell\_list() в метод run() перед обновлением поля pygame.display.flip().


Теперь осталось написать метод для обновления поля, чтобы состояния клеток менялись по описанным в начале правилам. Чтобы определить как должно измениться состояние клетки необходимо получить состояние ее соседей. Напишите функцию, которая получает для клетки список ее соседей:

def get\_neighbours(self, cell):  
    """  
    Вернуть список соседних клеток для клетки cell.

    Соседними считаются клетки по горизонтали,  
    вертикали и диагоналям, то есть во всех  
    направлениях.  
    """  
    pass

Теперь нужно написать функцию для обновления состояния всех клеток:

def update\_cell\_list(self, cell\_list):  
    """  
    Обновление состояния клеток  
    """  
    pass

Важно помнить, что обновление всего поля должно происходить за один раз, если состояние клеток менять последовательно, то это повлияет на результат игры.

Теперь у вас должна быть полностью рабочая игра.

Изменим дизайн нашей игры. Вы могли заметить, что клетка это объект, который имеет атрибут (поле) \- состояние; список клеток также является объектом, над которым можно выполнять такие действия как заполнение или обновление. Вашей задачей является написать два класса Cell CellList, которые представляют собой клетку и список ячеек (список объектов типа Cell). Ниже приведен пример интерфейса (возможных методов):

class Cell:

    def \_\_init\_\_(self, row, col, state=False):  
        pass

    def is\_alive(self):  
        pass

class CellList:

    def \_\_init\_\_(self, nrows, ncols, randomize=False):  
        pass

    def update(self):  
        pass

    def get\_neighbours(self, cell):  
        pass

    @classmethod  
    def from\_file(cls, filename):  
        pass

    def \_\_iter\_\_(self):  
        pass

    def \_\_next\_\_(self):  
        pass

    def \_\_str\_\_(self):  
        pass

Класс CellList должен быть итерируемым (реализовывать iterator protocol), например, так можно пройтись по списку клеток и оживить случайные клетки:

\>\>\> cell\_list \= CellList(nrow \= 6, ncol \= 8)  
\>\>\> for cell in cell\_list:  
        cell.state \= random.randint(0,1)  
\>\>\> print(cell\_list)  
\[\[1, 1, 0, 0, 1, 1, 1, 1\],  
 \[0, 1, 1, 1, 1, 1, 1, 0\],  
 \[1, 0, 1, 1, 0, 0, 0, 0\],  
 \[1, 0, 0, 0, 0, 0, 0, 1\],  
 \[1, 0, 1, 1, 1, 1, 0, 0\],  
 \[1, 1, 1, 1, 0, 1, 1, 1\]\]

Также в классе CellList должно быть предусмотрено заполнение списка клеток данными из файла:

\>\>\> cell\_list \= CellList.from\_file(filename \= 'game.txt')  
\>\>\> print(cell\_list)  
\[\[1, 1, 0, 0, 1, 1, 1, 1\],  
 \[0, 1, 1, 1, 1, 1, 1, 0\],  
 \[1, 0, 1, 1, 0, 0, 0, 0\],  
 \[1, 0, 0, 0, 0, 0, 0, 1\],  
 \[1, 0, 1, 1, 1, 1, 0, 0\],  
 \[1, 1, 1, 1, 0, 1, 1, 1\]\]

